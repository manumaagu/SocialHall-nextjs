import { Client as LibsqlClient, createClient } from "@libsql/client/web";
import { eventTable, linkedinMediaTable, pendingLinkedinTable, pendingTweetsTable, twitterMediaTable, usersTable } from '../db/schemes';
import { eq } from 'drizzle-orm';
import { TweetV2PostTweetResult, TwitterApi } from 'twitter-api-v2';
import { LibSQLDatabase, drizzle } from 'drizzle-orm/libsql';


export interface Env {
  LIBSQL_DB_URL?: string;
  LIBSQL_DB_AUTH_TOKEN?: string;
}


export default {
  async fetch(req, env: any, ctx): Promise<Response> {

    const client = buildLibsqlClient(env);

    const db = drizzle(client);

    checkAndPostLinkedin(db);

    console.log("[CRONJOB] - Checking for pending twitter posts" + client);
    const pendingTweets = await db.select().from(usersTable);
    console.log(pendingTweets);
    const html = `<!DOCTYPE html>
          <body>
            <h1>Hello World</h1>
            <p>This markup was generated by a Cloudflare Worker.</p>
          </body>`;

    return new Response(html, {
      headers: {
        "content-type": "text/html;charset=UTF-8",
      },
    });

  },
} satisfies ExportedHandler;

// async function checkAndPostTweets(db: LibSQLDatabase<Record<string, never>>) {
//   console.log("[CRONJOB] - Checking for pending twitter posts");

//   const pendingTweets = await db.select().from(pendingTweetsTable);

//   console.log(pendingTweets);

//   if (pendingTweets.length === 0) {
//     return;
//   }

//   for (const tweet of pendingTweets) {
//     const pendingId = tweet.id;
//     const twitterMedia = await db.select().from(twitterMediaTable).where(eq(twitterMediaTable.clerkId, tweet.clerkId));
//     // console.log(twitterMedia);

//     if (twitterMedia.length === 0) {
//       return;
//     }

//     const media = twitterMedia[0];
//     const content = tweet.content ? JSON.parse(tweet.content) : [];
//     const posts = JSON.parse(media.posts!) ?? [];

//     let tokenAccess = media.tokenAccess;
//     let tokenRefresh = media.tokenRefresh;
//     let tokenExpiration = media.tokenExpiration;
//     let client = new TwitterApi({ clientId: process.env.TWITTER_CLIENT_ID as string, clientSecret: process.env.TWITTER_CLIENT_SECRET as string });


//     if (tokenExpiration && Date.now() >= tokenExpiration) {  // Token expired so refresh it
//       const { client: refreshedClient, accessToken, refreshToken: newRefreshToken, expiresIn } = await client.refreshOAuth2Token(tokenRefresh!);
//       client = refreshedClient;
//       console.log("[CRONJOB] - Twitter token refreshed successfully");
//       await db.update(twitterMediaTable).set({ tokenAccess: accessToken, tokenRefresh: newRefreshToken, tokenExpiration: Date.now() + expiresIn * 1000 }).where(eq(twitterMediaTable.clerkId, tweet.clerkId));
//     } else {
//       client = new TwitterApi(tokenAccess!);
//     }

//     let postedTweet = null;

//     if (content.length > 1) {
//       postedTweet = await client.v2.tweetThread(content) as any[];
//     } else {
//       postedTweet = await client.v2.tweet(content[0].text) as any;

//       // TODO: Add poll support

//       // client.v2.tweet(tweet.content.text, { poll: { options: [], duration_minutes: 60 } })
//     }

//     console.log("[CRONJOB] - Twitter post posted successfully: ", postedTweet);

//     await db.update(eventTable).set({ posted: 1 }).where(eq(eventTable.id, pendingId));

//     const impressions = Math.floor(Math.random() * 1000);
//     const comments = Math.floor(impressions * 0.1);
//     const likes = Math.floor(impressions * 0.2);

//     const statisticsObject = {
//       "date": Date.now(),
//       "impressions": impressions,
//       "comments": comments,
//       "likes": likes,
//     }

//     const statisticsArray = [statisticsObject];

//     const tweetObject = {
//       id: postedTweet.data.id,
//       text: postedTweet.data.text,
//       date: new Date().getTime(),
//       statisticsArray: statisticsArray
//     }

//     posts.push(tweetObject);

//     console.log(posts);

//     await db.update(twitterMediaTable).set({ posts: JSON.stringify(posts) }).where(eq(twitterMediaTable.clerkId, tweet.clerkId));

//     await db.delete(pendingTweetsTable).where(eq(pendingTweetsTable.id, pendingId));
//   }
// }

// async function checkAndPostYoutube(db: LibSQLDatabase<Record<string, never>>) {
//   const pendingYoutube = await PendingYoutube.findPending();

//   console.log("[CRONJOB] - Checking for pending youtube posts");

//   if (pendingYoutube.length === 0) {
//     return;
//   }

//   for (const post of pendingYoutube) {
//     const pendingId = post.id;
//     const youtubeMedia = await YoutubeMedia.findByUser(post.clerkId);

//     if (!youtubeMedia || youtubeMedia.length === 0) {
//       continue;
//     }
//     const tokenRefresh = youtubeMedia[0].tokenRefresh;

//     const auth = new google.auth.OAuth2(
//       process.env.GOOGLE_CLIENT_ID,
//       process.env.GOOGLE_CLIENT_SECRET,
//       process.env.GOOGLE_CALLBACK_URL
//     );

//     auth.setCredentials({
//       refresh_token: tokenRefresh,
//     });

//     auth.on('tokens', async (tokens) => {
//       if (tokens.access_token) {
//         youtubeMedia[0].tokenAccess = tokens.access_token;
//         youtubeMedia[0].tokenExpiration = tokens.expiry_date;
//       }
//     });

//     const youtube = google.youtube({
//       version: 'v3',
//       auth
//     });

//     let body = {};

//     switch (post.content.type.toLowerCase()) {
//       case "short":
//         body = {
//           part: 'snippet,contentDetails,status',
//           resource: {
//             snippet: {
//               title: post.content.title,
//               description: post.content.description,
//               tags: ['shorts'],
//             },
//             status: {
//               privacyStatus: 'private'
//             }
//           },
//           media: {
//             body: fs.createReadStream(post.content.mediaPath)
//           }
//         }
//         break;
//       case "video":
//         body = {
//           part: 'snippet,contentDetails,status',
//           resource: {
//             snippet: {
//               title: post.content.title,
//               description: post.content.description
//             },
//             status: {
//               privacyStatus: 'private'
//             }
//           },
//           media: {
//             body: fs.createReadStream(post.content.mediaPath)
//           }
//         }
//         break;
//       default:
//         break;
//     }

//     const postedContent = await youtube.videos.insert(body);

//     if (postedContent.status !== 200) {
//       console.error("Error posting content to youtube");
//       console.log(postedContent);
//       continue;
//     }

//     fs.unlink(post.content.mediaPath, (err) => {
//       if (err) {
//         console.error("Error deleting file: ", err);
//       }
//     });

//     const event = await Event.findByPendingId(pendingId);
//     event[0].posted = true;

//     const impressions = Math.floor(Math.random() * 1000);
//     const comments = Math.floor(impressions * 0.1);
//     const likes = Math.floor(impressions * 0.2);

//     const statisticsObject = {
//       "date": Date.now(),
//       "impressions": impressions,
//       "comments": comments,
//       "likes": likes,
//     }

//     const statisticsArray = [statisticsObject];

//     const postObject = {
//       id: postedContent.data.id,
//       title: post.content.title,
//       description: post.content.description,
//       date: new Date().getTime(),
//       statisticsArray: statisticsArray
//     }

//     youtubeMedia[0].posts.push(postObject);

//     await youtubeMedia[0].save();
//     await event[0].save();

//     console.log("[CRONJOB] - Youtube video uploaded successfully: ", postedContent.data.id);

//     await post.delete();
//   }
// }

async function checkAndPostLinkedin(db: LibSQLDatabase<Record<string, never>>) {
  const pendingLinkedin = await db.select().from(pendingLinkedinTable);

  console.log("[CRONJOB] - Checking for pending linkedin posts");

  if (pendingLinkedin.length === 0) {
    return;
  }

  for (const post of pendingLinkedin) {
    const pendingId = post.id;
    const linkedinMedia = await db.select().from(twitterMediaTable).where(eq(linkedinMediaTable.clerkId, post.clerkId));

    if (!linkedinMedia || linkedinMedia.length === 0) {
      continue;
    }

    const media = linkedinMedia[0];
    const content = post.content ? JSON.parse(post.content) : [];
    const posts = JSON.parse(media.posts!) ?? [];

    if (Date.now() >= media.tokenExpiration!) {
      console.log("[CRONJOB] - Linkedin reauthorization needed");
      continue;
    }

    let body = {};

    switch (content!.shareMediaCategory.toLowerCase() as string) {
      case "none":
        body = {
          "author": "urn:li:person:" + media.profile_id,
          "lifecycleState": "PUBLISHED",
          "specificContent": {
            "com.linkedin.ugc.ShareContent": {
              "shareCommentary": {
                "text": content.shareCommentary
              },
              "shareMediaCategory": content.shareMediaCategory
            }
          },
          "visibility": {
            "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
          }
        }
        break;
      case "article":
        body = {
          "author": "urn:li:person:" + media.profile_id,
          "lifecycleState": "PUBLISHED",
          "specificContent": {
            "com.linkedin.ugc.ShareContent": {
              "shareCommentary": {
                "text": content.shareCommentary
              },
              "shareMediaCategory": "ARTICLE",
              "media": content.media
            }
          },
          "visibility": {
            "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
          }
        }
        break;
      case "image":
        body = {
          "author": "urn:li:person:" + media.profile_id,
          "lifecycleState": "PUBLISHED",
          "specificContent": {
            "com.linkedin.ugc.ShareContent": {
              "shareCommentary": {
                "text": content.shareCommentary
              },
              "shareMediaCategory": "IMAGE",
              "media": content.media
            }
          },
          "visibility": {
            "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
          }
        }
        break;
      case "video":
        body = {
          "author": "urn:li:person:" + media.profile_id,
          "lifecycleState": "PUBLISHED",
          "specificContent": {
            "com.linkedin.ugc.ShareContent": {
              "shareCommentary": {
                "text": content.shareCommentary
              },
              "shareMediaCategory": "VIDEO",
              "media": content.media
            }
          },
          "visibility": {
            "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
          }
        }
        break;
      default:
        break;
    }

    const accessToken = media.tokenAccess;

    const postedContent = await fetch('https://api.linkedin.com/v2/ugcPosts', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'X-Restli-Protocol-Version': '2.0.0',
        'Content-Type': 'application/json'
      },

      body: JSON.stringify(body)

    });

    if (postedContent.status !== 201) {
      console.error("Error posting content to linkedin");
      console.log(postedContent.statusText);
      continue;
    }

    await postEvent(pendingId, db);

    const postId = postedContent.headers.get('x-restli-id');

    const impressions = Math.floor(Math.random() * 1000);
    const comments = Math.floor(impressions * 0.1);
    const likes = Math.floor(impressions * 0.2);

    const statisticsObject = {
      "date": Date.now(),
      "impressions": impressions,
      "comments": comments,
      "likes": likes,
    }

    const statisticsArray = [statisticsObject];

    const postObject = {
      id: postId,
      text: content!.shareCommentary,
      date: new Date().getTime(),
      statisticsArray: statisticsArray
    }

    posts.push(postObject);


    await db.update(linkedinMediaTable).set({ posts: JSON.stringify(posts) }).where(eq(linkedinMediaTable.clerkId, post.clerkId));

    await db.delete(pendingLinkedinTable).where(eq(pendingLinkedinTable.id, pendingId));

    console.log("[CRONJOB] - Linkedin post uploaded successfully: ", postId);

  }
}


async function postEvent(pendingId: string, db: LibSQLDatabase<Record<string, never>>) {
  await db.update(eventTable).set({ posted: 1 }).where(eq(eventTable.id, pendingId));
}

function buildLibsqlClient(env: Env): LibsqlClient {
  const url = env.LIBSQL_DB_URL?.trim();
  if (url === undefined) {
    throw new Error("TURSO_URL env var is not defined");
  }

  const authToken = env.LIBSQL_DB_AUTH_TOKEN?.trim();
  if (authToken == undefined) {
    throw new Error("TURSO_AUTH_TOKEN env var is not defined");
  }

  return createClient({ url, authToken })
}